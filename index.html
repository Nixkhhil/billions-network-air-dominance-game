<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Aircraft Game</title>

    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex; /* कैनवास को center करने के लिए */
            align-items: center;
            justify-content: center;
            margin: 0;
            overflow: hidden; 
            height: 100vh; /* पूरी हाइट */
            width: 100vw; /* पूरी विड्थ */
        }

        h1 {
            display: none;
        }

        canvas {
            background-color: #000;
            border: 3px solid #fff;
            border-radius: 5px;
            cursor: none; 
            /* यह सुनिश्चित करेगा कि कैनवास स्क्रीन से बाहर न जाए */
            max-width: 100%;
            max-height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- कैनवास सेटअप ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // कैनवास को शुरू में एक डिफ़ॉल्ट आकार दें
        canvas.width = 300;
        canvas.height = 400;
        
        // --- गेम स्टेट वेरिएबल्स ---
        let playerHealth = 3;
        const maxPlayerHealth = 3;
        let score = 0;
        let nextBossScore = 200;
        let gameStarted = false; // BGM प्ले करने के लिए
        let gameOver = false;

        // --- प्लेयर ---
        let playerX = canvas.width / 2 - 25;
        let playerY = canvas.height - 70;
        const playerWidth = 50;
        const playerHeight = 50;

        // --- स्क्रॉलिंग बैकग्राउंड ---
        let bgY = 0;
        const bgSpeed = 1; 

        // --- शूटिंग ---
        let playerBullets = [];
        let enemyBullets = [];
        let playerShootTimer = 0;
        const playerShootCooldown = 15; 
        let doubleFireActive = false;
        let doubleFireTimer = 0;

        // --- दुश्मन ---
        let enemies = [];
        let enemySpawnTimer = 0;
        const enemySpawnRate = 100;

        // --- बॉस ---
        let bossActive = false;
        let bossHealth = 50;
        let bossX = canvas.width / 2 - 75;
        let bossY = -150;
        let bossWidth = 150;
        let bossHeight = 150;
        let bossShootTimer = 0;
        let bossMovingIn = false;

        // --- पॉवर-अप्स ---
        let powerUps = [];
        let shieldActive = false;
        let shieldTimer = 0;

        // --- सभी एसेट्स की लिस्ट (चेक करने के लिए) ---
        const assetList = [
            'assets/background.png',
            'assets/player.png',
            'assets/heart.png',
            'assets/enemy.png',
            'assets/boss.png',
            'assets/bullet_green.png',
            'assets/bullet_red.png',
            'assets/power_shield.png',
            'assets/power_double_fire.png',
            'assets/power_extra_life.png',
            'sounds/bgm.mpeg'
        ];

        let assetsLoadedCount = 0;
        const totalAssets = assetList.length;
        let failedAssets = []; // जो फ़ाइलें लोड नहीं हुईं
        let allAssetsChecked = false;

        // --- एसेट ऑब्जेक्ट्स ---
        const bgImage = new Image();
        const playerImage = new Image();
        const heartImage = new Image();
        const enemyImage = new Image();
        const bossImage = new Image();
        const bulletGreenImage = new Image();
        const bulletRedImage = new Image();
        const powerShieldImage = new Image();
        const powerDoubleImage = new Image();
        const powerLifeImage = new Image();
        const bgm = new Audio();
        bgm.loop = true;
        bgm.volume = 0.5;

        // एसेट्स को उनके सोर्स से मैप करना
        const assetMap = {
            'assets/background.png': bgImage,
            'assets/player.png': playerImage,
            'assets/heart.png': heartImage,
            'assets/enemy.png': enemyImage,
            'assets/boss.png': bossImage,
            'assets/bullet_green.png': bulletGreenImage,
            'assets/bullet_red.png': bulletRedImage,
            'assets/power_shield.png': powerShieldImage,
            'assets/power_double_fire.png': powerDoubleImage,
            'assets/power_extra_life.png': powerLifeImage,
            'sounds/bgm.mpeg': bgm
        };

        // --- नया: एसेट लोडिंग और एरर चेकिंग ---
        
        function assetLoaded(src) {
            console.log(`सफलतापूर्वक लोड हुई: ${src}`);
            assetsLoadedCount++;
            checkIfDone();
        }

        function assetFailed(src) {
            console.error(`लोड होने में विफल: ${src}`);
            failedAssets.push(src); // फ़ेल लिस्ट में जोड़ें
            checkIfDone(); // इसे भी गिना जाएगा
        }

        function checkIfDone() {
            // जब सभी एसेट्स (सफल या विफल) चेक हो जाएँ
            if (assetsLoadedCount + failedAssets.length === totalAssets) {
                allAssetsChecked = true;
                if (failedAssets.length === 0) {
                    // --- सफलता! ---
                    console.log("सभी एसेट्स लोड हो गए। गेम शुरू हो रहा है...");
                    resizeCanvas(); // कैनवास को 3:4 में सेट करें
                    gameLoop();     // गेम शुरू करें
                } else {
                    // --- विफलता! ---
                    console.error("कुछ एसेट्स लोड नहीं हुए। एरर स्क्रीन दिखा रहा है।");
                    resizeCanvas(); // कैनवास को 3:4 में सेट करें
                    drawErrorScreen(); // एरर स्क्रीन दिखाएँ
                }
            }
        }

        function loadAssets() {
            assetList.forEach(src => {
                const asset = assetMap[src];
                
                if (asset instanceof Image) {
                    asset.onload = () => assetLoaded(src);
                    asset.onerror = () => assetFailed(src);
                    asset.src = src;
                } else if (asset instanceof Audio) {
                    // 'canplaythrough' यह पक्का करता है कि ऑडियो लोड हो गया है
                    asset.oncanplaythrough = () => assetLoaded(src);
                    asset.onerror = () => assetFailed(src);
                    asset.src = src;
                    asset.load(); // ऑडियो को लोड करना शुरू करें
                }
            });
        }
        
        // --- नया: एरर स्क्रीन ड्रा करने का फंक्शन ---
        function drawErrorScreen() {
            // काली स्क्रीन
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // सफ़ेद बॉर्डर (जैसा आपके स्क्रीनशॉट में था)
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // एरर मैसेज
            ctx.fillStyle = 'red';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('गेम लोड नहीं हुआ!', canvas.width / 2, 50);

            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('ये फ़ाइलें नहीं मिलीं या नाम गलत है:', 20, 100);
            
            ctx.fillStyle = '#FFB3B3'; // हल्का लाल
            let yPos = 130;
            failedAssets.forEach(file => {
                ctx.fillText(file, 30, yPos);
                yPos += 25;
            });

            ctx.fillStyle = 'white';
            ctx.fillText('अपना /assets/ और /sounds/ फोल्डर चेक करें!', 20, yPos + 30);
        }

        // --- मोबाइल टच कंट्रोल्स ---
        function getTouchPos(canvasDom, touchEvent) {
            const rect = canvasDom.getBoundingClientRect();
            return {
                x: touchEvent.touches[0].clientX - rect.left,
                y: touchEvent.touches[0].clientY - rect.top
            };
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            
            // --- पहले टच पर BGM शुरू करें ---
            if (!gameStarted && allAssetsChecked && failedAssets.length === 0) {
                bgm.play().catch(e => console.error("ऑडियो प्ले नहीं हुआ:", e));
                gameStarted = true;
            }
            if (gameOver) {
                restartGame();
                return;
            }
            // --- BGM लॉजिक खत्म ---
            
            const touchPos = getTouchPos(canvas, e);
            playerX = touchPos.x - playerWidth / 2;
            playerY = touchPos.y - playerHeight / 2;
        }, false);

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            if (gameOver) return;
            const touchPos = getTouchPos(canvas, e);
            playerX = touchPos.x - playerWidth / 2;
            playerY = touchPos.y - playerHeight / 2;
        }, false);

        
        // --- गेम लॉजिक फंक्शन्स (पहले जैसे ही) ---

        function playerShoot() {
            const bulletX = playerX + playerWidth / 2 - 2.5;
            const bulletY = playerY;
            const bulletWidth = 5;
            const bulletHeight = 15;
            playerBullets.push({ x: bulletX, y: bulletY, width: bulletWidth, height: bulletHeight });

            if (doubleFireActive) {
                playerBullets.push({ x: bulletX - 10, y: bulletY, width: bulletWidth, height: bulletHeight });
                playerBullets.push({ x: bulletX + 10, y: bulletY, width: bulletWidth, height: bulletHeight });
            }
        }

        function spawnEnemy() {
            const enemyWidth = 50;
            const enemyHeight = 50;
            const enemyX = Math.random() * (canvas.width - enemyWidth);
            const enemyY = -enemyHeight;
            const enemySpeed = Math.random() * 2 + 1;
            enemies.push({ x: enemyX, y: enemyY, width: enemyWidth, height: enemyHeight, speed: enemySpeed, shootTimer: Math.random() * 100 + 50 });
        }
        
        function enemyShoot(enemy) {
            const bulletWidth = 8;
            const bulletHeight = 8;
            const bulletX = enemy.x + enemy.width / 2 - bulletWidth / 2;
            const bulletY = enemy.y + enemy.height;
            const bulletSpeed = 4;
            enemyBullets.push({x: bulletX, y: bulletY, width: bulletWidth, height: bulletHeight, speed: bulletSpeed});
        }

        function spawnBoss() {
            bossActive = true;
            bossHealth = 50;
            bossX = canvas.width / 2 - bossWidth / 2;
            bossY = -bossHeight;
            bossMovingIn = true;
            nextBossScore += 200; 
            enemies = []; 
        }

        function bossShoot() {
            const bulletSpeed = 5;
            const bulletWidth = 10;
            const bulletHeight = 10;
            const lanes = [0.2, 0.4, 0.6, 0.8]; // 4 लेन
            lanes.forEach(lane => {
                 enemyBullets.push({x: bossX + (bossWidth * lane) - bulletWidth/2, y: bossY + bossHeight, width: bulletWidth, height: bulletHeight, speed: bulletSpeed});
            });
        }
        
        function spawnPowerUp(x, y) {
            if (Math.random() < 0.1) { // 10% चांस
                let type;
                const rand = Math.random();
                if (rand < 0.33) type = 'life';
                else if (rand < 0.66) type = 'shield';
                else type = 'double';
                
                powerUps.push({ x: x, y: y, width: 30, height: 30, type: type, speed: 2 });
            }
        }

        function checkCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }

        function enemyKilled(enemyIndex) {
            spawnPowerUp(enemies[enemyIndex].x, enemies[enemyIndex].y);
            enemies.splice(enemyIndex, 1);
            score += 10;
        }

        function playerHit() {
            if (shieldActive) return;
            playerHealth--;
            if (playerHealth <= 0) {
                gameOver = true;
            }
        }

        function addLife() {
            if (playerHealth < maxPlayerHealth) playerHealth++;
        }
        
        function activateShield() {
            shieldActive = true;
            shieldTimer = 300; // 5 सेकंड
        }
        
        function activateDoubleFire() {
            doubleFireActive = true;
            doubleFireTimer = 300; // 5 सेकंड
        }

        function bossHit() {
            bossHealth--;
            score += 5;
            if (bossHealth <= 0) {
                bossActive = false;
                score += 500;
                spawnPowerUp(bossX + bossWidth * 0.2, bossY + bossHeight / 2);
                spawnPowerUp(bossX + bossWidth * 0.4, bossY + bossHeight / 2);
                spawnPowerUp(bossX + bossWidth * 0.6, bossY + bossHeight / 2);
            }
        }
        
        function restartGame() {
            playerHealth = 3;
            score = 0;
            nextBossScore = 200;
            enemies = [];
            playerBullets = [];
            enemyBullets = [];
            powerUps = [];
            bossActive = false;
            gameOver = false;
            playerX = canvas.width / 2 - playerWidth / 2;
            playerY = canvas.height - 70;
        }

        // --- मुख्य गेम लूप ---
        function gameLoop() {
            if (!gameOver) {
                update();
            }
            draw();
            // एरर स्क्रीन को अपडेट न करें, बस ड्रा करें
            if (allAssetsChecked && failedAssets.length === 0) {
                 requestAnimationFrame(gameLoop);
            }
        }

        // --- अपडेट फंक्शन (सबकुछ चलाता है) ---
        function update() {
            if (playerX < 0) playerX = 0;
            if (playerX > canvas.width - playerWidth) playerX = canvas.width - playerWidth;
            if (playerY < 0) playerY = 0;
            if (playerY > canvas.height - playerHeight) playerY = canvas.height - playerHeight;

            bgY += bgSpeed;
            if (bgY >= canvas.height) bgY = 0;
            
            if (shieldActive) {
                shieldTimer--;
                if (shieldTimer <= 0) shieldActive = false;
            }
            if (doubleFireActive) {
                doubleFireTimer--;
                if (doubleFireTimer <= 0) doubleFireActive = false;
            }

            playerShootTimer++;
            if (playerShootTimer >= playerShootCooldown) {
                playerShoot();
                playerShootTimer = 0;
            }

            for (let i = playerBullets.length - 1; i >= 0; i--) {
                playerBullets[i].y -= 7;
                if (playerBullets[i].y < 0) playerBullets.splice(i, 1);
            }
            
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                enemyBullets[i].y += enemyBullets[i].speed;
                if (enemyBullets[i].y > canvas.height) enemyBullets.splice(i, 1);
            }

            if (!bossActive) {
                enemySpawnTimer++;
                if (enemySpawnTimer >= enemySpawnRate) {
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }
                
                for (let i = enemies.length - 1; i >= 0; i--) {
                    let enemy = enemies[i];
                    enemy.y += enemy.speed;
                    enemy.shootTimer--;
                    if(enemy.shootTimer <= 0) {
                        enemyShoot(enemy);
                        enemy.shootTimer = 150 + Math.random() * 100;
                    }
                    if (enemy.y > canvas.height) enemies.splice(i, 1);
                }
            }
            
            if (bossActive) {
                if (bossMovingIn) {
                    bossY += 2;
                    if (bossY >= 50) bossMovingIn = false;
                }
                
                bossShootTimer++;
                if (bossShootTimer >= 80) {
                    bossShoot();
                    bossShootTimer = 0;
                }
            }
            
            for (let i = powerUps.length - 1; i >= 0; i--) {
                powerUps[i].y += powerUps[i].speed;
                if (powerUps[i].y > canvas.height) powerUps.splice(i, 1);
            }

            if (!bossActive && score >= nextBossScore) {
                spawnBoss();
            }

            const playerRect = {x: playerX, y: playerY, width: playerWidth, height: playerHeight};
            
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (checkCollision(playerBullets[i], enemies[j])) {
                        playerBullets.splice(i, 1);
                        enemyKilled(j);
                        break;
                    }
                }
            }
            
            if(bossActive) {
                const bossRect = {x: bossX, y: bossY, width: bossWidth, height: bossHeight};
                for (let i = playerBullets.length - 1; i >= 0; i--) {
                     if (checkCollision(playerBullets[i], bossRect)) {
                        playerBullets.splice(i, 1);
                        bossHit();
                        break;
                     }
                }
            }
            
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                if (checkCollision(enemyBullets[i], playerRect)) {
                    enemyBullets.splice(i, 1);
                    playerHit();
                    break;
                }
            }
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (checkCollision(enemies[i], playerRect)) {
                    enemies.splice(i, 1);
                    playerHit();
                    break;
                }
            }
            
            for (let i = powerUps.length - 1; i >= 0; i--) {
                if (checkCollision(powerUps[i], playerRect)) {
                    let power = powerUps[i];
                    if (power.type === 'life') addLife();
                    if (power.type === 'shield') activateShield();
                    if (power.type === 'double') activateDoubleFire();
                    powerUps.splice(i, 1);
                    break;
                }
            }
        }
        
        // --- ड्रा फंक्शन (स्क्रीन पर सब कुछ दिखाता है) ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(bgImage, 0, bgY, canvas.width, canvas.height);
            ctx.drawImage(bgImage, 0, bgY - canvas.height, canvas.width, canvas.height);
            ctx.drawImage(playerImage, playerX, playerY, playerWidth, playerHeight);
            
            if(shieldActive) {
                ctx.strokeStyle = 'cyan';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(playerX + playerWidth / 2, playerY + playerHeight / 2, playerWidth * 0.7, 0, Math.PI * 2);
                ctx.stroke();
            }

            for (const bullet of playerBullets) {
                ctx.drawImage(bulletGreenImage, bullet.x, bullet.y, bullet.width, bullet.height);
            }
            for (const bullet of enemyBullets) {
                ctx.drawImage(bulletRedImage, bullet.x, bullet.y, bullet.width, bullet.height);
            }
            for (const enemy of enemies) {
                ctx.drawImage(enemyImage, enemy.x, enemy.y, enemy.width, enemy.height);
            }
            
            if(bossActive) {
                ctx.drawImage(bossImage, bossX, bossY, bossWidth, bossHeight);
                ctx.fillStyle = 'red';
                ctx.fillRect(bossX, bossY - 15, bossWidth, 10);
                ctx.fillStyle = 'green';
                ctx.fil
